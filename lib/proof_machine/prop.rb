##
# Autogenerated from a Treetop grammar. Edits may be lost.


# This parser is a fork of my work on "rl" but now adapted to Guerzoni's 'LPC' syntax, where:
# A constant is T (verum) or ⊥ (falsum)
# A 'sentencial char' is pN (like p0, p1...)
# A formula: ϕ ::= (¬ϕ) | (ϕ ∧ ϕ) | (ϕ ∨ ϕ) | (ϕ → ϕ) | [A-Z] 
##

module PropositionalCalculus
  include Treetop::Runtime

  def root
    @root ||= :formula
  end

  module Formula0
    def expression1
      elements[0]
    end

    def binary_operator
      elements[1]
    end

    def expression2
      elements[2]
    end
  end

  module Formula1
    def content
      [ expression1.content, binary_operator.text_value, expression2.content ]
    end
  end

  def _nt_formula
    start_index = index
    if node_cache[:formula].has_key?(index)
      cached = node_cache[:formula][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_expression
    s1 << r2
    if r2
      r3 = _nt_binary_operator
      s1 << r3
      if r3
        r4 = _nt_expression
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Formula0)
      r1.extend(Formula1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_expression
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:formula][start_index] = r0

    r0
  end

  module Expression0
    def expression
      elements[1]
    end

  end

  module Expression1
    def content
      expression.content
    end
  end

  module Expression2
    def expression1
      elements[1]
    end

    def binary_operator
      elements[2]
    end

    def expression2
      elements[3]
    end

  end

  module Expression3
    def content
      [ expression1.content, binary_operator.text_value, expression2.content ]
    end
  end

  module Expression4
    def unary_operator
      elements[0]
    end

    def expression
      elements[1]
    end
  end

  module Expression5
    def content
      [ unary_operator.text_value, expression.content ]
    end
  end

  module Expression6
    def content
      text_value
    end
  end

  def _nt_expression
    start_index = index
    if node_cache[:expression].has_key?(index)
      cached = node_cache[:expression][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('(', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r2 = nil
    end
    s1 << r2
    if r2
      r3 = _nt_expression
      s1 << r3
      if r3
        if has_terminal?(')', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(')')
          r4 = nil
        end
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Expression0)
      r1.extend(Expression1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      if has_terminal?('(', false, index)
        r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('(')
        r6 = nil
      end
      s5 << r6
      if r6
        r7 = _nt_expression
        s5 << r7
        if r7
          r8 = _nt_binary_operator
          s5 << r8
          if r8
            r9 = _nt_expression
            s5 << r9
            if r9
              if has_terminal?(')', false, index)
                r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r10 = nil
              end
              s5 << r10
            end
          end
        end
      end
      if s5.last
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        r5.extend(Expression2)
        r5.extend(Expression3)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i11, s11 = index, []
        r12 = _nt_unary_operator
        s11 << r12
        if r12
          r13 = _nt_expression
          s11 << r13
        end
        if s11.last
          r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
          r11.extend(Expression4)
          r11.extend(Expression5)
        else
          @index = i11
          r11 = nil
        end
        if r11
          r0 = r11
        else
          r14 = _nt_atom
          r14.extend(Expression6)
          if r14
            r0 = r14
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:expression][start_index] = r0

    r0
  end

  def _nt_unary_operator
    start_index = index
    if node_cache[:unary_operator].has_key?(index)
      cached = node_cache[:unary_operator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_negation

    node_cache[:unary_operator][start_index] = r0

    r0
  end

  def _nt_binary_operator
    start_index = index
    if node_cache[:binary_operator].has_key?(index)
      cached = node_cache[:binary_operator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_conjunction
    if r1
      r0 = r1
    else
      r2 = _nt_disjunction
      if r2
        r0 = r2
      else
        r3 = _nt_implication
        if r3
          r0 = r3
        else
          r4 = _nt_biimplication
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:binary_operator][start_index] = r0

    r0
  end

  def _nt_negation
    start_index = index
    if node_cache[:negation].has_key?(index)
      cached = node_cache[:negation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('~', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('~')
      r0 = nil
    end

    node_cache[:negation][start_index] = r0

    r0
  end

  def _nt_implication
    start_index = index
    if node_cache[:implication].has_key?(index)
      cached = node_cache[:implication][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('=>', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('=>')
      r0 = nil
    end

    node_cache[:implication][start_index] = r0

    r0
  end

  def _nt_biimplication
    start_index = index
    if node_cache[:biimplication].has_key?(index)
      cached = node_cache[:biimplication][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('<=>', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('<=>')
      r0 = nil
    end

    node_cache[:biimplication][start_index] = r0

    r0
  end

  def _nt_conjunction
    start_index = index
    if node_cache[:conjunction].has_key?(index)
      cached = node_cache[:conjunction][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('^', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('^')
      r0 = nil
    end

    node_cache[:conjunction][start_index] = r0

    r0
  end

  def _nt_disjunction
    start_index = index
    if node_cache[:disjunction].has_key?(index)
      cached = node_cache[:disjunction][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('v', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('v')
      r0 = nil
    end

    node_cache[:disjunction][start_index] = r0

    r0
  end

  def _nt_atom
    start_index = index
    if node_cache[:atom].has_key?(index)
      cached = node_cache[:atom][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_proposition
    if r1
      r0 = r1
    else
      r2 = _nt_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:atom][start_index] = r0

    r0
  end

  def _nt_proposition
    start_index = index
    if node_cache[:proposition].has_key?(index)
      cached = node_cache[:proposition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[A-Z]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:proposition][start_index] = r0

    r0
  end

  def _nt_constant
    start_index = index
    if node_cache[:constant].has_key?(index)
      cached = node_cache[:constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_verum
    if r1
      r0 = r1
    else
      r2 = _nt_falsum
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:constant][start_index] = r0

    r0
  end

  def _nt_verum
    start_index = index
    if node_cache[:verum].has_key?(index)
      cached = node_cache[:verum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('true', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('true')
      r0 = nil
    end

    node_cache[:verum][start_index] = r0

    r0
  end

  def _nt_falsum
    start_index = index
    if node_cache[:falsum].has_key?(index)
      cached = node_cache[:falsum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('false', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('false')
      r0 = nil
    end

    node_cache[:falsum][start_index] = r0

    r0
  end

end

class PropositionalCalculusParser < Treetop::Runtime::CompiledParser
  include PropositionalCalculus
end
